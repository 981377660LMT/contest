/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author
 */

#include <iostream>
#include <fstream>
#include<iomanip>

//
// Created by DALT on 12/9/2019.
//

#ifndef JHELPER_EXAMPLE_PROJECT_COMMON_H
#define JHELPER_EXAMPLE_PROJECT_COMMON_H

#include <bits/stdc++.h>
#include <chrono>
#include <random>

using std::deque;
using std::endl;
using std::map;
using std::max;
using std::min;
using std::pair;
using std::set;
using std::swap;
using std::vector;
using std::ios_base;
using std::ostream;
using std::istream;
using std::string;
using std::fill;
using std::sort;
using std::numeric_limits;
using std::make_pair;
using std::priority_queue;
using std::iterator;

typedef unsigned int ui;
typedef long long ll;
typedef long double ld;
typedef unsigned long long ull;
std::mt19937 rng(std::chrono::steady_clock::now().time_since_epoch().count());

#endif //JHELPER_EXAMPLE_PROJECT_COMMON_H

//
// Created by DALT on 12/15/2019.
//

#ifndef JHELPER_EXAMPLE_PROJECT_PRESUM_H
#define JHELPER_EXAMPLE_PROJECT_PRESUM_H



namespace dalt {
    template<typename T>
    class presum {
    public:
        presum(int cap) : _vec(cap) {
        }

        presum(const presum<T> &vec) : _vec(vec._vec), _n(vec._n) {
        }

        void populate(vector<T> vec) {
            _vec.begin();
            _vec.clear();
            _vec.insert(_vec.end(), vec.begin(), vec.end());
            _n = _vec.size();
            for (int i = 1; i < _n; i++) {
                _vec[i] += _vec[i - 1];
            }
        };

        T interval(int l, int r){
            if(l > r){
                return 0;
            }
            T ans = _vec[r];
            if(l > 0){
                ans -= _vec[l - 1];
            }
            return ans;
        }
    private:
        vector<T> _vec;
        int _n;
    };
}

#endif //JHELPER_EXAMPLE_PROJECT_PRESUM_H


using namespace dalt;

#define MAX_H_W 600
vector<vector<int>> grids(MAX_H_W, vector<int>(MAX_H_W));
vector<presum<int>> rows(MAX_H_W, presum<int>(MAX_H_W));
vector<presum<int>> cols(MAX_H_W, presum<int>(MAX_H_W));
vector<vector<int>> colPoints(MAX_H_W, vector<int>(MAX_H_W));
vector<presum<int>> colSums(MAX_H_W, presum<int>(MAX_H_W));


class tenka1_2018_e {
public:
    void solve(std::istream &in, std::ostream &out) {
        int h, w;
        in >> h >> w;
        for (int i = 0; i < h; i++) {
            for (int j = 0; j < w; j++) {
                char c;
                in >> c;
                if (c == '#') {
                    grids[i + j][i + w - j] = 1;
                }
            }
        }

        for (int i = 0; i < MAX_H_W; i++) {
            rows[i].populate(grids[i]);
        }
        vector<int> col(MAX_H_W);
        for (int i = 0; i < MAX_H_W; i++) {
            for (int j = 0; j < MAX_H_W; j++) {
                col[j] = grids[j][i];
            }
            colSums[i].populate(col);
        }

        ll ans = 0;
        for (int i = 1; i < MAX_H_W; i++) {
            for (int j = 0; j < MAX_H_W; j++) {
                for (int k = 0; k < MAX_H_W; k++) {
                    if (grids[j][k] && j + i < MAX_H_W && grids[j + i][k]) {
                        colPoints[k][j] = 1;
                    } else {
                        colPoints[k][j] = 0;
                    }
                }
            }

            for (int j = 0; j < MAX_H_W; j++) {
                cols[j].populate(colPoints[j]);
            }

            for (int j = 0; j < MAX_H_W; j++) {
                for (int k = 0; k < MAX_H_W; k++) {
                    if (grids[j][k] == 0) {
                        continue;
                    }

                    int origin = ans;
                    if (j - i >= 0 && k + i < MAX_H_W) {
                        ans += rows[j - i].interval(k + 1, k + i - 1) * grids[j][k + i];
                    }
                    if (k + i < MAX_H_W) {
                        ans += cols[k + i].interval(max(0, j - i), j);
                    }
                    if (j + i < MAX_H_W && k + i < MAX_H_W) {
                        ans += grids[j][k + i] * rows[j + i].interval(k, k + i - 1);
                    }
                    if (j + i < MAX_H_W && k + i < MAX_H_W) {
                        ans += grids[j + i][k] * colSums[k + i].interval(j + 1, j + i);
                    }

//                    if (origin < ans) {
//                        std::cerr << "i=" << i << ", j=" << j << ", k=" << k << ": " << ans - origin << endl;
//                    }
                }
            }
        }

        out << ans;
    }

private:
};


int main() {
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(NULL);
	std::cout << std::setiosflags(std::ios::fixed);
	std::cout << std::setprecision(15);

	tenka1_2018_e solver;
	std::istream& in(std::cin);
	std::ostream& out(std::cout);
	solver.solve(in, out);
	return 0;
}
