/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author
 */

#include <iostream>
#include <fstream>
#include<iomanip>

//
// Created by DALT on 12/9/2019.
//

#ifndef COMMON_H
#define COMMON_H

#include <bits/stdc++.h>
#include <chrono>
#include <random>

using std::deque;
using std::endl;
using std::map;
using std::max;
using std::min;
using std::pair;
using std::set;
using std::swap;
using std::vector;
using std::ios_base;
using std::ostream;
using std::istream;
using std::string;
using std::fill;
using std::sort;
using std::numeric_limits;
using std::make_pair;
using std::priority_queue;
using std::iterator;
using std::cerr;

typedef unsigned int ui;
typedef long long ll;
typedef long double ld;
typedef unsigned long long ull;
std::mt19937 rng(std::chrono::steady_clock::now().time_since_epoch().count());

namespace dalt{};
namespace other{};

#endif //COMMON_H

//
// Created by daltao on 2019/12/16.
//

#ifndef DEBUG_H
#define DEBUG_H

#endif //DEBUG_H


using namespace dalt;

namespace dalt {
    class enhanced_segment {
    public:
        enhanced_segment(int l, int r) {
            _cnt = 0;
            _l = _r = 0;
            _v = 0;
            _index = 0;

            int m = (l + r) >> 1;
            if (l < r) {
                _l = new enhanced_segment(l, m);
                _r = new enhanced_segment(m + 1, r);
                pushUp();
            } else {
                _index = l;
            }
        }

#define NO_INTERSECTION ql > r || qr < l
#define COVER ql <= l && qr >= r
#define RANGE (min(qr, r) - max(l, ql) + 1)

        void update(int ql, int qr, int l, int r, ll x, ll cnt) {
            if (NO_INTERSECTION) {
                return;
            }
            if (COVER) {
                modify(x, cnt);
                return;
            }
            pushDown();
            int m = (l + r) >> 1;
            _l->update(ql, qr, l, m, x, cnt);
            _r->update(ql, qr, m + 1, r, x, cnt);
            pushUp();
        }

        ll query(int ql, int qr, int l, int r) {
            if (NO_INTERSECTION) {
                return 0;
            }
            if (COVER) {
                return _v + _cnt * _index;
            }
            pushDown();
            int m = (l + r) >> 1;
            return _l->query(ql, qr, l, m) +
                   _r->query(ql, qr, m + 1, r);
        }

#undef NO_INTERSECTION
#undef COVER

    private:
        enhanced_segment *_l, *_r;
        ll _v;
        int _index;
        ll _cnt;

        void pushDown() {
            if (_v || _cnt) {
                _l->modify(_v, _cnt);
                _r->modify(_v, _cnt);
                _v = _cnt = 0;

            }
        }

        void pushUp() {
        }

        void modify(ll d, ll cnt) {
            _v += d;
            _cnt += cnt;
        }
    };
}

namespace dalt {
    struct segment_query_result {
        int index;
        int val;

        segment_query_result() {
            init();
        }

        void init() {
            index = -1;
            val = -1;
        }

        void update(int i, int v) {
            if (v > val) {
                val = v;
                index = i;
            }
        }
    };

    class segment {
    public:
        segment(int l, int r, vector<int> &vec) {
            int m = (l + r) >> 1;
            if (l < r) {
                _l = new segment(l, m, vec);
                _r = new segment(m + 1, r, vec);
                pushUp();
            } else {
                _v = vec[l];
                _index = l;
            }
        }

#define NO_INTERSECTION ql > r || qr < l
#define COVER ql <= l && qr >= r
#define RANGE (min(qr, r) - max(l, ql) + 1)

        void query(int ql, int qr, int l, int r, segment_query_result &ans) {
            if (NO_INTERSECTION) {
                return;
            }
            if (COVER) {
                ans.update(_index, _v);
                return;
            }
            pushDown();
            int m = (l + r) >> 1;
            _l->query(ql, qr, l, m, ans);
            _r->query(ql, qr, m + 1, r, ans);
        }

#undef NO_INTERSECTION
#undef COVER

    private:
        segment *_l, *_r;
        int _v;
        int _index;

        void pushDown() {
        }

        void pushUp() {
            if (_l->_v >= _r->_v) {
                _v = _l->_v;
                _index = _l->_index;
            } else {
                _v = _r->_v;
                _index = _r->_index;
            }
        }

        void modify() {
        }
    };
}

struct Query {
    int l;
    int r;
    ll ans;
    Query *next;
};

int n;
segment *rmq;
enhanced_segment *lSeg;
enhanced_segment *rSeg;
vector<Query *> queryBindToElement;

void dfs(int l, int r) {
    if (l > r) {
        return;
    }

    segment_query_result rmqResult;
    rmq->query(l, r, 0, n, rmqResult);
    int mid = rmqResult.index;
    dfs(l, mid - 1);
    dfs(mid + 1, r);

    for (Query *q = queryBindToElement[mid]; q; q = q->next) {
        q->ans = (q->r - q->l + 1);
        q->ans += lSeg->query(q->r, q->r, 0, n);
        q->ans += rSeg->query(q->l, q->l, 0, n);
    }

    ll lPart = 0;
    if (l < mid) {
        lPart = lSeg->query(mid - 1, mid - 1, 0, n);
    }
    lSeg->update(mid, r, 0, n, lPart - (l - 1), 1);

    ll rPart = 0;
    if (r > mid) {
        rPart = rSeg->query(mid + 1, mid + 1, 0, n);
    }
    rSeg->update(l, mid, 0, n, rPart + (r + 1), -1);
}


class GRecursiveQueries {
public:

    void solve(std::istream &in, std::ostream &out) {
        int q;
        in >> n >> q;
        vector<int> ps(n + 1);
        for (int i = 0; i < n; i++) {
            in >> ps[i];
        }
        vector<Query> queries(q);
        for (int i = 0; i < q; i++) {
            in >> queries[i].l;
            queries[i].l--;
        }
        for (int i = 0; i < q; i++) {
            in >> queries[i].r;
            queries[i].r--;
        }

        rmq = new segment(0, n, ps);
        lSeg = new enhanced_segment(0, n);
        rSeg = new enhanced_segment(0, n);

        queryBindToElement.resize(n);
        for (int i = 0; i < q; i++) {
            segment_query_result result;
            rmq->query(queries[i].l, queries[i].r, 0, n, result);
            queries[i].next = queryBindToElement[result.index];
            queryBindToElement[result.index] = &queries[i];
        }

        dfs(0, n - 1);
        for (int i = 0; i < q; i++) {
            out << queries[i].ans << endl;
        }
    }

private:
};


int main() {
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(NULL);
	std::cout << std::setiosflags(std::ios::fixed);
	std::cout << std::setprecision(15);

	GRecursiveQueries solver;
	std::istream& in(std::cin);
	std::ostream& out(std::cout);
	solver.solve(in, out);
	return 0;
}
