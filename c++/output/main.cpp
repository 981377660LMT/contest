/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author
 */

#include <iostream>
#include <fstream>
#include<iomanip>

//
// Created by DALT on 12/9/2019.
//

#ifndef JHELPER_EXAMPLE_PROJECT_COMMON_H
#define JHELPER_EXAMPLE_PROJECT_COMMON_H

#include <bits/stdc++.h>
#include <chrono>
#include <random>

using std::deque;
using std::endl;
using std::map;
using std::max;
using std::min;
using std::pair;
using std::set;
using std::swap;
using std::vector;
using std::ios_base;
using std::ostream;
using std::istream;
using std::string;
using std::fill;
using std::sort;
using std::numeric_limits;
using std::make_pair;
using std::priority_queue;

typedef unsigned int ui;
typedef long long ll;
typedef long double ld;
typedef unsigned long long ull;
std::mt19937 rng(std::chrono::steady_clock::now().time_since_epoch().count());

#endif //JHELPER_EXAMPLE_PROJECT_COMMON_H


#define MAX 2048
class segment {
public:
    segment(int l, int r): _l(0), _r(0),
    _sum(0), _mod(0){
        int m = (l + r) >> 1;
        if(l < r){
            _l = new segment(l, m);
            _r = new segment(m + 1, r);
            pushUp();
        }else{

        }
    }

#define NO_INTERSECTION ql > r || qr < l
#define COVER ql <= l && qr >= r
#define RANGE (min(qr, r) - max(l, ql) + 1)
    void update(int ql, int qr, int l, int r, ll mod) {
        if (NO_INTERSECTION) {
            return;
        }
        if (COVER) {
            _mod += mod;
            return;
        }
        pushDown();
        int m = (l + r) >> 1;
        _l->update(ql, qr, l, m, mod);
        _r->update(ql, qr, m + 1, r, mod);
        _sum += mod * RANGE;
        pushUp();
    }

    ll query(int ql, int qr, int l, int r) {
        if (NO_INTERSECTION) {
            return 0;
        }
        if (COVER) {
            return _sum + _mod * RANGE;
        }
        pushDown();
        int m = (l + r) >> 1;
        return _l->query(ql, qr, l, m) +
        _r->query(ql, qr, m + 1, r) +
        _mod * RANGE;
    }

#undef NO_INTERSECTION
#undef COVER

private:
    segment *_l, *_r;

    void pushDown() {
    }

    void pushUp() {
    }

    void modify() {
    }

    ll _sum;
    ll _mod;
};

class segment2d {
public:
    segment2d(int l, int r): _mod(1, MAX),
    _sum(1, MAX), _l(0), _r(0){
        int m = (l + r) >> 1;
        if(l < r){
            _l = new segment2d(l, m);
            _r = new segment2d(m + 1, r);
            pushUp();
        }else{
        }
    }

#define NO_INTERSECTION ql > r || qr < l
#define COVER ql <= l && qr >= r
#define RANGE (min(qr, r) - max(l, ql) + 1)
    void update(int ql, int qr, int qb, int qt, int l, int r, int b, int t, ll mod) {
        if (NO_INTERSECTION) {
            return;
        }
        if (COVER) {
            _mod.update(qb, qt, b, t, mod);
            return;
        }
        pushDown();
        int m = (l + r) >> 1;
        _l->update(ql, qr, qb, qt, l, m, b, t, mod);
        _r->update(ql, qr, qb, qt, m + 1, r, b, t, mod);
        _sum.update(qb, qt, b, t, RANGE * mod);
        pushUp();
    }

    ll query(int ql, int qr, int qb, int qt, int l, int r, int b, int t) {
        if (NO_INTERSECTION) {
            return 0;
        }
        if (COVER) {
            return _sum.query(qb, qt, b, t) +
            _mod.query(qb, qt, b, t) * RANGE;
        }
        pushDown();
        int m = (l + r) >> 1;
        return _l->query(ql, qr, qb, qt, l, m, b, t) +
        _r->query(ql, qr, qb, qt, m + 1, r, b, t) +
        _mod.query(qb, qt, b, t) * RANGE;
    }

#undef NO_INTERSECTION
#undef COVER

private:
    segment2d *_l, *_r;
    segment _mod, _sum;

    void pushDown() {
    }

    void pushUp() {
    }

    void modify() {
    }
};


class LUOGU4514 {
public:
    void solve(std::istream &in, std::ostream &out) {
        char cmd;
        int n;
        int m;
        in >> cmd >> n >> m;

        segment2d seg(1, MAX);
        while(!in.eof()){
            in >> cmd;
            int a, b, c, d;
            in >> a >> b >> c >> d;
            int bot = min(b, d);
            int top = max(b, d);
            int left = min(a, c);
            int right = max(a, c);
            if(cmd == 'L'){
                int delta;
                in >> delta;
                seg.update(left, right, bot, top, 1, MAX, 1, MAX, delta);
            }else{
                ll ans = seg.query(left, right, bot, top, 1, MAX, 1, MAX);
                out << ans << endl;
            }
        }
    }

private:
};


int main() {
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(NULL);
	std::cout << std::setiosflags(std::ios::fixed);
	std::cout << std::setprecision(15);

	LUOGU4514 solver;
	std::istream& in(std::cin);
	std::ostream& out(std::cout);
	solver.solve(in, out);
	return 0;
}
