/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author
 */

#include <iostream>
#include <fstream>
#include<iomanip>

//
// Created by DALT on 12/9/2019.
//

#ifndef JHELPER_EXAMPLE_PROJECT_COMMON_H
#define JHELPER_EXAMPLE_PROJECT_COMMON_H

#include <bits/stdc++.h>
#include <chrono>
#include <random>

using std::deque;
using std::endl;
using std::map;
using std::max;
using std::min;
using std::pair;
using std::set;
using std::swap;
using std::vector;
using std::ios_base;
using std::ostream;
using std::istream;
using std::string;
using std::fill;
using std::sort;
using std::numeric_limits;
using std::make_pair;
using std::priority_queue;
using std::iterator;
using std::cerr;

typedef unsigned int ui;
typedef long long ll;
typedef long double ld;
typedef unsigned long long ull;
std::mt19937 rng(std::chrono::steady_clock::now().time_since_epoch().count());

namespace dalt{};
namespace other{};

#endif //JHELPER_EXAMPLE_PROJECT_COMMON_H

//
// Created by daltao on 2019/12/16.
//

#ifndef JHELPER_EXAMPLE_PROJECT_DEBUG_H
#define JHELPER_EXAMPLE_PROJECT_DEBUG_H

#endif //JHELPER_EXAMPLE_PROJECT_DEBUG_H

//
// Created by daltao on 2019/12/16.
//

#ifndef JHELPER_EXAMPLE_PROJECT_LICHAO_SEGMENT_H
#define JHELPER_EXAMPLE_PROJECT_LICHAO_SEGMENT_H



namespace other {
#define INF 1e18

    template<class T>
    struct lichao_line {
        T k, m;

        lichao_line(T _k, T _m) { k = _k, m = _m; }

        lichao_line() : lichao_line((T)0, (T)-INF) {}

        T get(T x) { return k * x + m; }

        bool majorize(lichao_line X, ll L, ll R) {
            return get(L) >= X.get(L) && get(R) >= X.get(R);
        }
    };

    template<class T>
    struct lichao_segment {
        lichao_segment<T> *c[2];
        lichao_line<T> S;

        lichao_segment() {
            c[0] = c[1] = NULL;
            S = lichao_line<T>();
        }

        void rm() {
            if (c[0]) c[0]->rm();
            if (c[1]) c[1]->rm();
            delete this;
        }

        void mc(int i) {
            if (!c[i]) c[i] = new lichao_segment<T>();
        }

        ll query(ll X, ll L, ll R) {
            ll ans = S.get(X), M = (L + R) / 2;
            if (X <= M) return max(ans, c[0] ? c[0]->query(X, L, M) : (T)-INF);
            return max(ans, c[1] ? c[1]->query(X, M + 1, R) : (T)-INF);
        }

        void modify(const lichao_line<T> &X, ll L, ll R) {
            if (X.majorize(S, L, R)) swap(X, S);
            if (S.majorize(X, L, R)) return;
            if (S.get(L) < X.get(L)) swap(X, S);

            ll M = (L + R) / 2;
            if (X.get(M) >= S.get(M)) swap(X, S), mc(0), c[0]->modify(X, L, M);
            else mc(1), c[1]->modify(X, M + 1, R);
        }

        void upd(const lichao_line<T> &X, ll lo, ll hi, ll L, ll R) { // untested
            if (R < lo || L > hi) return;
            if (lo <= L && R <= hi) {
                modify(X, L, R);
                return;
            }
            ll M = (L + R) / 2;
            mc(0), c[0]->upd(X, lo, hi, L, M);
            mc(1), c[1]->upd(X, lo, hi, M + 1, R);
        }
    };

#undef INF
}

#endif //JHELPER_EXAMPLE_PROJECT_LICHAO_SEGMENT_H


using namespace other;
typedef lichao_line<ll> dlc_line;
typedef lichao_segment<ll> dlc_seg;

vector<int> queries;
vector<dlc_line> status;
vector<int> since;

#define MAX_TIME (ll)1e9

dlc_line reverse(const dlc_line &line){
    return dlc_line(-line.k, -line.m);
}

class UOJ88 {
public:

    void solve(std::istream &in, std::ostream &out) {
        int n, m;
        in >> n >> m;
        status.reserve(n);
        queries.reserve(m);
        since.resize(n, 0);
        for (int i = 0; i < n; i++) {
            int a;
            in >> a;
            status.push_back(dlc_line(0, a));
        }
        dlc_seg upper;
        dlc_seg bot;
        for(int i = 0; i < m; i++){
            int time;
            string type;
            in >> time >> type;
            if(type == "query"){
                queries.push_back(time);
            }else{
                int which, dir;
                in >> which >> dir;
                which--;
                upper.upd(status[which], since[which], time, 0, MAX_TIME);
                bot.upd(reverse(status[which]), since[which], time, 0, MAX_TIME);
                ll x = status[which].get(time);
                status[which] = dlc_line(dir, x - (ll)dir * time);
                since[which] = time;
            }
        }

        for(int i = 0; i < n; i++){
            upper.upd(status[i], since[i], MAX_TIME, 0, MAX_TIME);
            bot.upd(reverse(status[i]), since[i], MAX_TIME, 0, MAX_TIME);
//            std::cerr << i <<  "=" << status[i].k << "x" << "+" << status[i].m
//            << "(" << since[i] << ")" << endl;
        }

        for(int q : queries){
            ll pos = upper.query(q, 0, MAX_TIME);
            ll neg = bot.query(q, 0, MAX_TIME);
            ll ans = max(abs(pos), abs(neg));
            out << ans << endl;
        }
    }

private:
};


int main() {
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(NULL);
	std::cout << std::setiosflags(std::ios::fixed);
	std::cout << std::setprecision(15);

	UOJ88 solver;
	std::istream& in(std::cin);
	std::ostream& out(std::cout);
	solver.solve(in, out);
	return 0;
}
